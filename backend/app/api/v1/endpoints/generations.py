"""
Generation endpoints for code generation API
"""

import asyncio
from typing import Dict, List, Any, Optional
from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.services.code_generator import CodeGenerator, get_code_generator
from app.services.ai_service import AIService, get_ai_service
from app.services.sandbox_manager import SandboxManager, get_sandbox_manager
from app.core.websocket_manager import websocket_manager

router = APIRouter()


class GenerationRequest(BaseModel):
    """Request model for code generation"""
    prompt: str = Field(..., description="Natural language description of the application")
    project_id: Optional[int] = Field(None, description="Project ID to associate with generation")
    context: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Additional context")
    stream: bool = Field(False, description="Whether to stream the response")
    client_id: Optional[str] = Field(None, description="WebSocket client ID for real-time updates")


class GenerationResponse(BaseModel):
    """Response model for generation status"""
    generation_id: str
    status: str
    message: str
    created_at: str
    project_id: Optional[int] = None


class GenerationStatusResponse(BaseModel):
    """Response model for generation status"""
    id: str
    project_id: Optional[int]
    status: str
    created_at: str
    completed_at: Optional[str]
    agents: Dict[str, Any]
    artifacts: List[str]
    errors: List[str]


class GenerationArtifactsResponse(BaseModel):
    """Response model for generation artifacts"""
    generation_id: str
    artifacts: Dict[str, Any]


@router.post("/", response_model=GenerationResponse)
async def create_generation(
    request: GenerationRequest,
    background_tasks: BackgroundTasks,
    code_generator: CodeGenerator = Depends(get_code_generator),
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new code generation request
    
    This endpoint starts a multi-agent code generation process that will:
    1. Analyze the requirements (Architect agent)
    2. Generate frontend code (Frontend Developer agent)
    3. Generate backend code (Backend Developer agent)
    4. Create tests (Tester agent)
    5. Review code quality (Reviewer agent)
    """
    try:
        # Start generation crew
        generation_id = await code_generator.kickoff_crew(
            prompt=request.prompt,
            project_id=request.project_id,
            client_id=request.client_id,
            context=request.context
        )
        
        return GenerationResponse(
            generation_id=generation_id,
            status="started",
            message="Generation crew started successfully",
            created_at=code_generator.active_generations[generation_id]["created_at"].isoformat(),
            project_id=request.project_id
        )
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to start generation: {str(e)}")


@router.get("/{generation_id}/status", response_model=GenerationStatusResponse)
async def get_generation_status(
    generation_id: str,
    code_generator: CodeGenerator = Depends(get_code_generator)
):
    """
    Get the status of a generation request
    
    Returns detailed information about the generation process including:
    - Current status
    - Agent completion status
    - Available artifacts
    - Any errors encountered
    """
    try:
        status = await code_generator.get_generation_status(generation_id)
        if not status:
            raise HTTPException(status_code=404, detail="Generation not found")
        
        return GenerationStatusResponse(**status)
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get generation status: {str(e)}")


@router.get("/{generation_id}/artifacts", response_model=GenerationArtifactsResponse)
async def get_generation_artifacts(
    generation_id: str,
    code_generator: CodeGenerator = Depends(get_code_generator)
):
    """
    Get the artifacts generated by a generation request
    
    Returns all generated code, tests, documentation, and other artifacts
    from the multi-agent generation process.
    """
    try:
        artifacts = await code_generator.get_generation_artifacts(generation_id)
        if artifacts is None:
            raise HTTPException(status_code=404, detail="Generation not found")
        
        return GenerationArtifactsResponse(
            generation_id=generation_id,
            artifacts=artifacts
        )
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get generation artifacts: {str(e)}")


@router.post("/{generation_id}/cancel")
async def cancel_generation(
    generation_id: str,
    code_generator: CodeGenerator = Depends(get_code_generator)
):
    """
    Cancel an active generation request
    
    Stops the multi-agent generation process and cleans up resources.
    """
    try:
        success = await code_generator.cancel_generation(generation_id)
        if not success:
            raise HTTPException(status_code=404, detail="Generation not found")
        
        return {"message": "Generation cancelled successfully"}
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to cancel generation: {str(e)}")


@router.get("/", response_model=List[GenerationStatusResponse])
async def list_generations(
    code_generator: CodeGenerator = Depends(get_code_generator)
):
    """
    List all generation requests
    
    Returns a list of all generation requests with their current status.
    """
    try:
        generations = await code_generator.list_generations()
        return [GenerationStatusResponse(**gen) for gen in generations]
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to list generations: {str(e)}")


@router.post("/{generation_id}/deploy")
async def deploy_generation(
    generation_id: str,
    sandbox_manager: SandboxManager = Depends(get_sandbox_manager),
    code_generator: CodeGenerator = Depends(get_code_generator),
    db: AsyncSession = Depends(get_db)
):
    """
    Deploy a completed generation to a sandbox
    
    Creates a new sandbox container and deploys the generated code for testing.
    """
    try:
        # Get generation artifacts
        artifacts = await code_generator.get_generation_artifacts(generation_id)
        if not artifacts:
            raise HTTPException(status_code=404, detail="Generation not found or not completed")
        
        # Extract frontend code
        frontend_code = artifacts.get("frontend", "")
        if not frontend_code:
            raise HTTPException(status_code=400, detail="No frontend code found in artifacts")
        
        # Create sandbox
        sandbox_id = await sandbox_manager.create_sandbox(
            project_id=generation_id,
            code=frontend_code,
            dependencies={
                "dependencies": {
                    "react": "^18.2.0",
                    "react-dom": "^18.2.0",
                    "typescript": "^5.0.0",
                    "vite": "^5.0.0",
                    "@vitejs/plugin-react": "^4.0.0",
                    "tailwindcss": "^3.3.0",
                    "autoprefixer": "^10.4.0",
                    "postcss": "^8.4.0"
                },
                "devDependencies": {
                    "@types/react": "^18.2.0",
                    "@types/react-dom": "^18.2.0",
                    "@typescript-eslint/eslint-plugin": "^6.0.0",
                    "@typescript-eslint/parser": "^6.0.0",
                    "eslint": "^8.45.0",
                    "eslint-plugin-react-hooks": "^4.6.0",
                    "eslint-plugin-react-refresh": "^0.4.3",
                    "vitest": "^0.34.0"
                }
            }
        )
        
        return {
            "message": "Generation deployed to sandbox successfully",
            "sandbox_id": sandbox_id,
            "generation_id": generation_id
        }
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to deploy generation: {str(e)}")


@router.post("/stream")
async def stream_generation(
    request: GenerationRequest,
    ai_service: AIService = Depends(get_ai_service)
):
    """
    Stream a code generation response
    
    Returns a streaming response for real-time code generation.
    """
    try:
        if not request.stream:
            raise HTTPException(status_code=400, detail="Streaming must be enabled for this endpoint")
        
        # This would be implemented with Server-Sent Events or WebSocket
        # For now, return a simple response
        return {
            "message": "Streaming generation started",
            "client_id": request.client_id
        }
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to start streaming generation: {str(e)}")


@router.post("/{generation_id}/optimize")
async def optimize_generation(
    generation_id: str,
    ai_service: AIService = Depends(get_ai_service),
    code_generator: CodeGenerator = Depends(get_code_generator)
):
    """
    Optimize a completed generation
    
    Uses AI to optimize the generated code for performance, readability, and best practices.
    """
    try:
        # Get generation artifacts
        artifacts = await code_generator.get_generation_artifacts(generation_id)
        if not artifacts:
            raise HTTPException(status_code=404, detail="Generation not found")
        
        # Optimize frontend code
        frontend_code = artifacts.get("frontend", "")
        if frontend_code:
            optimized_frontend = await ai_service.optimize_code(frontend_code)
            artifacts["frontend"] = optimized_frontend
        
        # Optimize backend code
        backend_code = artifacts.get("backend", "")
        if backend_code:
            optimized_backend = await ai_service.optimize_code(backend_code)
            artifacts["backend"] = optimized_backend
        
        return {
            "message": "Generation optimized successfully",
            "artifacts": artifacts
        }
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to optimize generation: {str(e)}")


@router.post("/{generation_id}/explain")
async def explain_generation(
    generation_id: str,
    ai_service: AIService = Depends(get_ai_service),
    code_generator: CodeGenerator = Depends(get_code_generator)
):
    """
    Get an explanation of the generated code
    
    Uses AI to provide a detailed explanation of the generated code.
    """
    try:
        # Get generation artifacts
        artifacts = await code_generator.get_generation_artifacts(generation_id)
        if not artifacts:
            raise HTTPException(status_code=404, detail="Generation not found")
        
        # Combine all code for explanation
        all_code = "\n\n".join([
            artifacts.get("frontend", ""),
            artifacts.get("backend", ""),
            artifacts.get("tests", "")
        ])
        
        if not all_code:
            raise HTTPException(status_code=400, detail="No code found in artifacts")
        
        # Generate explanation
        explanation = await ai_service.explain_code(all_code)
        
        return {
            "generation_id": generation_id,
            "explanation": explanation
        }
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to explain generation: {str(e)}")
